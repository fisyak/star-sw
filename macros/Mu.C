/* 
   root.exe lMuDst.C Mu.C+
   root.exe lMuDst.C Mu.root
>> .L Mumc.C+;  Init(0); DrawEff(); DrawQA();
*/
#if !defined(__CINT__) || defined(__MAKECINT__)
#include <assert.h>
#include <map>
#include <utility>
#include "Riostream.h"
#include "Rtypes.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TH2.h"
#include "TH3.h"
#include "TF1.h"
#include "TProfile.h"
#include "TProfile3D.h"
#include "TTree.h"
#include "TChain.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TClassTable.h"
#include "TFile.h"
#include "TChain.h"
#include "TString.h"
#include "SystemOfUnits.h"
#include "StMuDSTMaker/COMMON/StMuTimer.h"
#include "StMuDSTMaker/COMMON/StMuDebug.h"
#include "StMuDSTMaker/COMMON/StMuDst.h"
#include "StMuDSTMaker/COMMON/StMuEvent.h"
#include "StMuDSTMaker/COMMON/StMuTrack.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcTrack.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryTrackCovariance.h"
#include "StarRoot/TPolynomial.h"
#include "StDcaGeometry.h"
#include "TRSymMatrix.h"
#include "THelixTrack.h"
#include "Names.h"
#include "StBichsel/Bichsel.h"
#define ClassStMessMgr
#define StMessMgr Int_t
#include "StMuDSTMaker/COMMON/StMuDstMaker.h"
#undef  StMessMgr
#undef ClassStMessMgr
#else
#ifndef __MAKECINT__
#define BIT(n)       (1 << (n))
#define SETBIT(n,i)  ((n) |= (1 << i))
#define CLRBIT(n,i)  ((n) &= ~(1 << i))
#define TESTBIT(n,i) ((Bool_t)(((n) & (1 << i)) != 0))
class StMuDstMaker;
#endif
#endif
StMuDstMaker* maker = 0;
enum TrackMatchType {kPositive, kNegative, kTotalSigns};                                     // switch between charges
struct PlotName_t {
  TrackMatchType    k;
  const Char_t *Name;
  const Char_t *Title;
};
struct VarName_t {
  const Char_t *Name;
  const Char_t *Title;
  Int_t nx;
  Double_t xmin, xmax;
  Int_t ny;
  Double_t ymin, ymax;
  Int_t nz;
  Double_t zmin, zmax;
  Double_t  min,  max; // min and max for plots
};
const Char_t *NameCharge[kTotalSigns] = {"Pos", "Neg"};
const Char_t *TitleCharge[kTotalSigns] = {"(+)", "(-)"};
//________________________________________________________________________________
static Int_t _debug = 0;
void SetDebug(Int_t k) {_debug = k;}
Int_t Debug() {return _debug;}
//________________________________________________________________________________
Int_t SectorNumber(Float_t x, Float_t y, Float_t z) {
  Double_t phi = TMath::RadToDeg()*TMath::ATan2(y,x);
  Int_t iphi = TMath::Nint(phi/30.);
  Int_t Sector;
  if (z > 0) {
    Sector = 3 - iphi;
    if (Sector <=  0) Sector += 12;
  } else {
    Sector = 21 + iphi;
    if (Sector > 24) Sector -= 12;
  }
  return Sector;
}
//________________________________________________________________________________
Bool_t Accept(const StMuTrack *gTrack = 0) {
  if (! gTrack)            return kFALSE;
  //  if (! gTrack->idTruth()) return kFALSE;
  if (! gTrack->charge())  return kFALSE;
  if (  gTrack->flag() < 100 ||  gTrack->flag()%100 == 11) return kFALSE; // bad fit or short track pointing to EEMC
  if (  gTrack->flag() > 1000) return kFALSE;  // pile up track in TPC
  if (  gTrack->nHitsFit() < 10) return kFALSE;
  //  if (  gTrack->qaTruth() < 90) return kFALSE;
  return kTRUE;
}
//________________________________________________________________________________
Bool_t AcceptVX(const StMuPrimaryVertex *Vtx = 0) {
  if (! Vtx) return kFALSE;
  if (! Vtx->idTruth())  return kFALSE;
  //  if (  Vtx->qaTruth() < 90) return kFALSE;
  return kTRUE;
}
//________________________________________________________________________________
void Mu(Long64_t nevent = 9999999,
	  //	  const char* file="/star/rcf/test/dev/trs_sl302.ittf/Wed/year_2011/pp500_pileup/rcf10100_90_200evts_Wplus_enu.MuDst.root",
	//	const char* file="MuDstSel.lis",
	const char* file="*.MuDst.root",
	const char* filter="st:MuDst.root",
	const  char* outFile="MupTES.root") {
#if 1
  TFile *fOut = new TFile(outFile,"recreate");
  TH1F *hpT[kTotalSigns];
  TH3F *hpTES[kTotalSigns];
  for (Int_t s = kPositive; s < kTotalSigns; s++) {
    hpT[s] = new TH1F(Form("pT%s",NameCharge[s]),Form("pT for %s",TitleCharge[s]),200,0,200);
    hpTES[s] = new TH3F(Form("pTES%s",NameCharge[s]),Form("pT and #eta versus sector for %s",TitleCharge[s]),24,0.5,24.5,200,0.,2.0,50,-2.5,2.5);
  }
  TH2F *RZF = new TH2F("RZF","R vesus Z of the first global track point",210,-210,210,210,0,210);
  RZF->SetXTitle("Z of first hit on global track");
  RZF->SetYTitle("R of first hit on global track");
  TH2F *RZL = new TH2F("RZL","R vesus Z of the last global track point",210,-210,210,210,0,210);
  RZL->SetXTitle("Z of last hit on global track");
  RZL->SetYTitle("R of last hit on global track");
#endif
  StMuDebug::setLevel(0);  
  maker = new StMuDstMaker(0,0,"",file,filter,1e9);   // set up maker in read mode
  //                       0,0                        this mean read mode
  //                           dir                    read all files in this directory
  //                               file               bla.lis real all file in this list, if (file!="") dir is ignored
  //                                    filter        apply filter to filenames, multiple filters are separated by ':'
  //                                          10      maximum number of file to read
  maker->SetStatus("*",0);
  const Char_t *ActiveBranches[] = {"MuEvent"
				    ,"PrimaryVertices"
				    ,"PrimaryTracks"
				    ,"GlobalTracks"
#if 0
				    ,"CovPrimTrack"
				    ,"CovGlobTrack"
				    ,"StStMuMcVertex"
				    ,"StStMuMcTrack"
#endif
  };
  Int_t Nb = sizeof(ActiveBranches)/sizeof(Char_t *);
  for (Int_t i = 0; i < Nb; i++) maker->SetStatus(ActiveBranches[i],1); // Set Active braches
  StMuDebug::setLevel(0);  
  TChain *tree = maker->chain();
  if (! tree) return;
  Long64_t nentries = tree->GetEntries();
  nevent = TMath::Min(nevent,nentries);
  cout << nentries << " events in chain " << nevent << " will be read." << endl;
  //  if (nentries < 100) return;
  tree->SetCacheSize(-1);        //by setting the read cache to -1 we set it to the AutoFlush value when writing
  tree->SetCacheLearnEntries(1); //one entry is sufficient to learn
  tree->SetCacheEntryRange(0,nevent);

  for (Long64_t ev = 0; ev < nevent; ev++) {
    if (maker->Make()) break;
    StMuDst* mu = maker->muDst();   // get a pointer to the StMuDst class, the class that points to all the data
    if (ev%1000 == 0) cout << "Read event\t" << ev << endl;
    StMuEvent* muEvent = mu->event(); // get a pointer to the class holding event-wise information
    // cout << " #" << ev;
    //    Int_t referenceMultiplicity = muEvent->refMult(); // get the reference multiplicity
    // cout << " refMult= "<< referenceMultiplicity;
    TClonesArray *PrimaryVertices   = mu->primaryVertices(); 
    Int_t NoPrimaryVertices = PrimaryVertices->GetEntriesFast();  // cout << "\tPrimaryVertices " << NoPrimaryVertices;
    TClonesArray *PrimaryTracks    = mu->array(muPrimary);  
    Int_t NoPrimaryTracks = PrimaryTracks->GetEntriesFast();  // cout << "\tPrimaryTracks " << NoPrimaryTracks;
    TClonesArray *GlobalTracks     = mu->array(muGlobal);  
    Int_t NoGlobalTracks = GlobalTracks->GetEntriesFast();        if (Debug()) {cout << "\tGlobalTracks " << NoGlobalTracks;}
    TClonesArray *CovPrimTrack     = mu->covPrimTrack();          if (Debug()) {cout << "\tCovPrimTrack " << CovPrimTrack->GetEntriesFast();}
#if 0
    TClonesArray *CovGlobTrack     = mu->covGlobTrack();          if (Debug()) {cout << "\tCovGlobTrack " << CovGlobTrack->GetEntriesFast();}
#endif
    for (Int_t l = 0; l < NoPrimaryVertices; l++) {
      StMuPrimaryVertex *Vtx = (StMuPrimaryVertex *) PrimaryVertices->UncheckedAt(l);
      if (l) continue;
#if 0
      cout << *Vtx << endl;
#endif
      for (Int_t k = 0; k < NoGlobalTracks; k++) {
	StMuTrack *gTrack = (StMuTrack *) GlobalTracks->UncheckedAt(k);
	cout << &gTrack << endl;
	RZF->Fill(gTrack->firstPoint().z(), gTrack->firstPoint().perp());
	RZL->Fill(gTrack->lastPoint().z(), gTrack->lastPoint().perp());
      }
      for (Int_t k = 0; k < NoPrimaryTracks; k++) {
	StMuTrack *pTrack = (StMuTrack *) PrimaryTracks->UncheckedAt(k);
	if (! pTrack) continue;
        if (pTrack->vertexIndex() != l) continue;
	if (! Accept(pTrack)) continue;
	TrackMatchType s = kPositive;
	if (pTrack->charge() < 0) s = kNegative;
	Int_t kg = pTrack->index2Global();
	if (kg < 0 || kg > NoGlobalTracks) continue;
	StMuTrack *gTrack = (StMuTrack *) GlobalTracks->UncheckedAt(kg);
	if (! gTrack) continue;
#if 0
	cout << *pTrack << endl;
	Int_t kpc = pTrack->index2Cov();
	if (kpc < 0) continue;
	StMuPrimaryTrackCovariance *cov = (StMuPrimaryTrackCovariance *) CovPrimTrack->UncheckedAt(kpc);
	TRSymMatrix Cp(3,cov->errMatrix());
	Int_t kgc = gTrack->index2Cov();
	if (kgc < 0) continue;
	StDcaGeometry *dcaG = (StDcaGeometry *) CovGlobTrack->UncheckedAt(kgc);
	cout << *dcaG << endl;
	TRSymMatrix Cg(5,dcaG->errMatrix());
	//	if (GlobalTracks_mNHitsFit[kg] < 15) continue;
	Double_t VV[2][3] = { // nV
	  {TMath::Sqrt(Cp(2,2))*pTrack->pt(), TMath::Sqrt(Cp(0,0)), TMath::Sqrt(Cp(1,1))},
	  {TMath::Sqrt(Cg(3,3))*dcaG->pt()   , TMath::Sqrt(Cg(4,4)), TMath::Sqrt(Cg(2,2))}
	};
	if (VV[0][0] > 0.05) {
	  pTrack->Print(); dcaG->Print(); gTrack->Print();
	}
#endif
#if 1
	hpT[s]->Fill(pTrack->pt());
	Int_t sec = SectorNumber(gTrack->firstPoint().x(), gTrack->firstPoint().y(), gTrack->firstPoint().z());
	hpTES[s]->Fill(sec, pTrack->pt(), pTrack->eta());
#endif
      }
    }
  }
#if 1
  if (fOut) fOut->Write();
#endif
}



