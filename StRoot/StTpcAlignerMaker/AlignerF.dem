/*
   rmaxima -g -b AlignerF.dem
*/

load ("eigen")$
load (f90)$
:lisp (setq *f90-output-line-length-max* 1000000000) 
stardisp: true$
algebraic : true $
simplified_output: true$
inflag : true$
debugmode(true) $ 
/*
     Position of TPC as Whole in STAR Magnet coordinate system, Whole TPC = 0.5 * (West + East Wheel), direction === Center of East Hweel to Center of Whest Wheel) 
     Global <=> TPCE =   StGlobalCoordinate <=> StTpcLocalCoordinate   
                         StTpcDb::Tpc2GlobalMatrix() = StTpcPosition::instance()->GetMatrix();

     TPCE <=> TPGV[2] => StTpcDb::TpcHalf(StBeamDirection part)
                                                    mHalf[east} = StTpcHalfPosition::instance()->GetEastMatrix()
                                                    mHalf[west] = StTpcHalfPosition::instance()->GetWestMatrix();   
     TPCE <=> SubS||Pad  =     StTpcLocalCoordinate <=> StTpcLocalSectorCoordinate

     
  mShift[0] = new TGeoTranslation("Signed Drift distance to z for East", 0, 0, -mzGG);
  mShift[1] = new TGeoTranslation("Signed Drift distance to z for West", 0, 0,  mzGG);

*/
iphi(sector) := block([i],
    (if (sector <= 12) then i : (360 + 90 - 30* sector      )
    else                    i : (      90 + 30*(sector - 12))),
    if (i > 360) then i : i - 360,
    if (i <   0) then i : i + 360,
    return (i)
)$
RotateZ(sector) := block([rotA],
  i   : iphi(sector),	
  phi : %pi/180*i,
  c   : cos(phi),
  s   : sin(phi),
  rotA: matrix([c, -s, 0, 0],
	       [s,  c, 0, 0],
               [0,  0, 1, 0],
               [0,  0, 0, 1]),
 return (rotA)
);
RotM(sector) := block([rotmZ],
  if (sector <=12) then rotm : matrix([1, 0, 0, 0],[0, 1, 0, 0],[0, 0, 1, 0],[0, 0, 0, 1])
  else                  rotm : matrix([1, 0, 0, 0],[0,-1, 0, 0],[0, 0,-1, 0],[0, 0, 0, 1]),
	rotmZ : rotm . RotateZ(sector),
  return (rotmZ)
);
RotM(1);
RotM(13);
/* iphi(12); */
Flip():= matrix([ 0, 1,  0,  0],
              [ 1, 0,  0,  0],
              [ 0, 0, -1,  0],
              [ 0, 0,  0,  1])$
part(s) := if (s > 12) then 0 else 1$
zGG(s)  := block( if equal(part(s), 0) then -zG else zG);  /* zG = 208.707 cm distance to Gating Grid */
zWW(s)  := block( if equal(part(s), 0) then -zW else zW); /* zW = 229.71 cm -"-      to Wheel */
Shift(s) := matrix([1, 0, 0, 0],
                   [0, 1, 0, 0],
                   [0, 0, 1, zWW(s)],
                   [0, 0, 0, 1])$            
dR( alpha,beta,gamma, x_0, y_0, z_0) := 
matrix([     1,-gamma,   beta, x_0],
       [ gamma,      1,-alpha, y_0],
       [ -beta, alpha,      1, z_0],
       [     0,     0,      0,   1]);
dRT( alpha,beta,gamma, x_0, y_0, z_0) := /* dR^-1 */
matrix([     1, gamma,  -beta,-x_0],
       [-gamma,      1, alpha,-y_0],
       [  beta,-alpha,      1,-z_0],
       [     0,     0,      0,   1]);
Half(s,a_E, b_E, g_E, x_E, y_E, z_E,  z_W) := 
block(
	if equal(part(s), 0) then dR(a_E, b_E, g_E, x_E, y_E, z_E)
                             else dR(a_W, b_W, g_W, x_W, y_W, z_W)
);
Tpc2Glob(a_Tpc, b_Tpc, g_Tpc, x_Tpc, y_Tpc, z_Tpc) := dR(a_Tpc, b_Tpc, g_Tpc, x_Tpc, y_Tpc, z_Tpc);
Tpc2GlobT(a_Tpc, b_Tpc, g_Tpc, x_Tpc, y_Tpc, z_Tpc) := dRT(a_Tpc, b_Tpc, g_Tpc, x_Tpc, y_Tpc, z_Tpc);

Sup12ST(a_s, b_s, g_s, x_s, y_s, z_s)  :=  dRT(a_s, b_s, g_s, x_s, y_s, z_s);
dSup12ST(da_s, db_s, dg_s, dx_s, dy_s, dz_s) := dRT(da_s, db_s, dg_s, dx_s, dy_s, dz_s);
 
/*
Sup12S2Tpc(sector, a_s, b_s, g_s, x_s, y_s, z_s) := Shift(sector) . Half(sector) . RotM(sector) . Flip . dR(sector, a_s, b_s, g_s, x_s, y_s, z_s) . ddR(sector, da_s, db_s, dg_s, dx_s, dy_s, dz_sz);
*/
rG: matrix([xG], [yG], [zG], [1]);    /* Global coordinates and direction */
nG: matrix([nxG], [nyG], [nzG], [0]); 
r: matrix([x], [y], [z], [1]);        /* Supersector coordinates and direction */
n: matrix([nx], [ny], [nz], [0]); 
/*  
                             Outer to Inner 
*/
rI: matrix([xI], [yI], [zI], [1]);    /* Inner sector coordinates and direction */
nI: matrix([nxI], [nyI], [nzI], [0]); 
rO: matrix([xO], [yO], [zO], [1]);    /* Outer sector coordinates and direction */
nO: matrix([nxO], [nyO], [nzO], [0]); 

dRI( a_I, b_I, g_I, x_I, y_I, z_I) := dR(a_I, b_I, g_I, x_I, y_I, z_I);
ddRI(da_I, db_I, dg_I, dx_I, dy_I, dz_I) := dR(da_I, db_I, dg_I, dx_I, dy_I, dz_I);
dRIT( a_I, b_I, g_I, x_I, y_I, z_I) := dRT(a_I, b_I, g_I, x_I, y_I, z_I);
ddRIT(da_I, db_I, dg_I, dx_I, dy_I, dz_I) := dRT(da_I, db_I, dg_I, dx_I, dy_I, dz_I);

dRO( a_O, b_O, g_O, x_O, y_O, z_O) := dR(a_O, b_O, g_O, x_O, y_O, z_O);
ddRO(da_O, db_O, dg_O, dx_O, dy_O, dz_O) := dR(da_O, db_O, dg_O, dx_O, dy_O, dz_O);
dROT( a_O, b_O, g_O, x_O, y_O, z_O) := dRT(a_O, b_O, g_O, x_O, y_O, z_O);
ddROT(da_O, db_O, dg_O, dx_O, dy_O, dz_O) := dRT(da_O, db_O, dg_O, dx_O, dy_O, dz_O);
/* g_Wheel : 0; x_Wheel : 0; y_Wheel : 0; z_Wheel : 0; */
Wheel( a_Wheel, b_Wheel) := dR(a_Wheel, b_Wheel, 0, 0, 0, 0);
WheelT( a_Wheel, b_Wheel) := dRT(a_Wheel, b_Wheel,0, 0, 0, 0); 

/* 
     kSubs2Tpc    = *mShift[part]) * (*mHalf[part]) * (*rotm) * Flip * TpcSuperSectorPosition * dR *        GG(z) * Wheel * dR" * kSubS(Inner|Outer)2SupS ||  kPad(Inner|Outer)2SupS * GG^-1(z)
                                                          
   r = Sup12 = GG(z) * Wheel * dRR * (kSubS(Inner|Outer)2SupS ||  kPad(Inner|Outer)2SupS) * GG^-1(z) * r(I|O)
	                dR" == ddR   <--                      dR                      -->
   r = GG(z) * Wheel * ddRI * dRI * GG^-1(z) * rI
   r = GG(z) * Wheel * ddRO * dRO * GG^-1(z) * rO
   rI = (GG(z) * Wheel * ddRI * dRI * GG^-1(z))^-1 * r =  (GG(z) * dRIT * ddRIT * WheelT * GGT(z)) * r = (GG(z) * WheelT * GGT(z)) * r; at ddRI * dRI == I
   rO = (GG(z) * Wheel * ddRO * dRO * GG^-1(z))^-1 * r =  (GG(z) * dROT * ddROT * WheelT * GGT(z)) * r
dR"_Outer = ddRO * dRO
   z = r[3];
   rI =  (GG(z) * WheelT * GGT(z)) * r                    === fRPad
   rO =  (GG(z) * dROT * ddROT * WheelT * GGT(z)) * r     ===  -"-

                  GW = GGT(z) * Wheel
	fRPadGG = GW^-1 * r; On Wheel 

*/
GG(z) := matrix([1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, 1,-z],
                [0, 0, 0, 1])$            
GGT(z):= matrix([1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, 1, z],
                [0, 0, 0, 1])$            

RS2I(z, a_I, b_I, g_I, x_I, y_I, z_I, da_I, db_I, dg_I, dx_I, dy_I, dz_I, a_Wheel, b_Wheel)  := GG(z) . dRI( a_I, b_I, g_I, x_I, y_I, z_I) . ddRIT(da_I, db_I, dg_I, dx_I, dy_I, dz_I) . WheelT( a_Wheel, b_Wheel) . GGT(z);
/*
(%i53) RS2IC : RS2I(z, a_I, b_I, g_I, x_I, y_I, z_I, da_I, db_I, dg_I, dx_I, dy_I, dz_I, a_Wheel, b_Wheel)  ;
(%o53) matrix(
[(- (b_Wheel*da_I - dg_I)*g_I) + b_I*(db_I + b_Wheel) - b_Wheel*db_I + 1, (- (1 - a_Wheel*da_I)*g_I) + dg_I + a_Wheel*db_I + b_I*((- da_I) - a_Wheel), (- (b_Wheel*dg_I + da_I + a_Wheel)*g_I) + a_Wheel*dg_I + b_I*((- b_Wheel*db_I) - a_Wheel*da_I + 1) - db_I - b_Wheel, 
(- g_I*(b_Wheel*dg_I*z + da_I*z + a_Wheel*z - dy_I)) + b_I*((- b_Wheel*db_I*z) - a_Wheel*da_I*z + z - dz_I) + a_Wheel*dg_I*z - db_I*z - b_Wheel*z + x_I - dx_I], [(1 - b_Wheel*db_I)*g_I - dg_I - a_I*(db_I + b_Wheel) + b_Wheel*da_I, 
(dg_I + a_Wheel*db_I)*g_I - a_Wheel*da_I - a_I*((- da_I) - a_Wheel) + 1, (a_Wheel*dg_I - db_I - b_Wheel)*g_I + b_Wheel*dg_I - a_I*((- b_Wheel*db_I) - a_Wheel*da_I + 1) + da_I + a_Wheel, 
g_I*(a_Wheel*dg_I*z - db_I*z - b_Wheel*z - dx_I) - a_I*((- b_Wheel*db_I*z) - a_Wheel*da_I*z + z - dz_I) + b_Wheel*dg_I*z + da_I*z + a_Wheel*z + y_I - dy_I], [a_I*(b_Wheel*da_I - dg_I) - b_I*(1 - b_Wheel*db_I) + db_I + b_Wheel, 
(- b_I*(dg_I + a_Wheel*db_I)) + a_I*(1 - a_Wheel*da_I) - da_I - a_Wheel, 
a_I*(b_Wheel*dg_I + da_I + a_Wheel) - b_I*(a_Wheel*dg_I - db_I - b_Wheel) - b_Wheel*db_I - a_Wheel*da_I + 1, 
z_I + a_I*(b_Wheel*dg_I*z + da_I*z + a_Wheel*z - dy_I) - b_I*(a_Wheel*dg_I*z - db_I*z - b_Wheel*z - dx_I) - b_Wheel*db_I*z - a_Wheel*da_I*z - dz_I], 
[0, 0, 0, 1])

(%i54) RS2IC : RS2I(z, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a_Wheel, b_Wheel)  ;
                [    1         0      - b_Wheel  - b_Wheel*z ]
                [                                            ]
                [    0         1       a_Wheel    a_Wheel*z  ]
(%o54)          [                                            ]
                [ b_Wheel  - a_Wheel      1           0      ]
                [                                            ]
                [    0         0          0           1      ]
*/
RS2O(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)  := GG(z) . dRO( a_O, b_O, g_O, x_O, y_O, z_O) . ddROT(da_O, db_O, dg_O, dx_O, dy_O, dz_O) . WheelT( a_Wheel, b_Wheel) . GGT(z);
/*
(%i55) RS2OC : RS2O(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel);
(%o55) matrix(
[(- (b_Wheel*da_O - dg_O)*g_O) + b_O*(db_O + b_Wheel) - b_Wheel*db_O + 1,
 (- (1 - a_Wheel*da_O)*g_O) + dg_O + a_Wheel*db_O + b_O*((- da_O) - a_Wheel),
 (- (b_Wheel*dg_O + da_O + a_Wheel)*g_O) + a_Wheel*dg_O + b_O*((- b_Wheel*db_O) - a_Wheel*da_O + 1) - db_O - b_Wheel, 
(- g_O*(b_Wheel*dg_O*z + da_O*z + a_Wheel*z - dy_O)) + b_O*((- b_Wheel*db_O*z) - a_Wheel*da_O*z + z - dz_O) + a_Wheel*dg_O*z - db_O*z - b_Wheel*z + x_O - dx_O
], 
[(1 - b_Wheel*db_O)*g_O - dg_O - a_O*(db_O + b_Wheel) + b_Wheel*da_O, 
(dg_O + a_Wheel*db_O)*g_O - a_Wheel*da_O - a_O*((- da_O) - a_Wheel) + 1, 
(a_Wheel*dg_O - db_O - b_Wheel)*g_O + b_Wheel*dg_O - a_O*((- b_Wheel*db_O) - a_Wheel*da_O + 1) + da_O + a_Wheel, 
g_O*(a_Wheel*dg_O*z - db_O*z - b_Wheel*z - dx_O) - a_O*((- b_Wheel*db_O*z) - a_Wheel*da_O*z + z - dz_O) + b_Wheel*dg_O*z + da_O*z + a_Wheel*z + y_O - dy_O
], 
[a_O*(b_Wheel*da_O - dg_O) - b_O*(1 - b_Wheel*db_O) + db_O + b_Wheel, 
(- b_O*(dg_O + a_Wheel*db_O)) + a_O*(1 - a_Wheel*da_O) - da_O - a_Wheel, 
a_O*(b_Wheel*dg_O + da_O + a_Wheel) - b_O*(a_Wheel*dg_O - db_O - b_Wheel) - b_Wheel*db_O - a_Wheel*da_O + 1, 
z_O + a_O*(b_Wheel*dg_O*z + da_O*z + a_Wheel*z - dy_O) - b_O*(a_Wheel*dg_O*z - db_O*z - b_Wheel*z - dx_O) - b_Wheel*db_O*z - a_Wheel*da_O*z - dz_O
], 
[0, 0, 0, 1])
=>

[1, (- g_O + dg_O - a_Wheel), - a_Wheel*da_O + 1 - db_O - b_Wheel,  - db_O*z - b_Wheel*z + x_O - dx_O], 
[g_O - dg_O, 1,  - a_O + da_O + a_Wheel,  (- a_O  + da_O + a_Wheel)*z + y_O - dy_O], 
[- b_O + db_O + b_Wheel, a_O - da_O - a_Wheel, 1, z_O  - dz_O], 
[0, 0, 0, 1])

*/
rIF(z, a_Wheel, b_Wheel) := RS2I(z,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a_Wheel, b_Wheel) . r;
nIF(z, a_Wheel, b_Wheel) := RS2I(z,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a_Wheel, b_Wheel) . n;

rON(z, a_O, b_O, g_O, x_O, y_O, z_O, a_Wheel, b_Wheel)                                     := RS2O(z, a_O, b_O, g_O, x_O, y_O, z_O, 0, 0, 0, 0, 0, 0, a_Wheel, b_Wheel)  . r; /* no update   ddRO */
rOU(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) := RS2O(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) . r; /* with update ddRO */
/*  Freeze parameters 
a_I : 0; b_I : 0; g_I : 0; x_I : 0; y_I : 0; z_I : 0;
a_O : 0; b_O : 0;
g_Wheel : 0; x_Wheel : 0; y_Wheel : 0; z_Wheel : 0;
*/
nOF(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)  := RS2O(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) . n;

drO(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) := rOU(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) - rON(z, a_O, b_O, g_O, x_O, y_O, z_O, a_Wheel, b_Wheel);

Step(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) := 
drO(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[2]/nOF(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[2];

nS(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) := 
Step(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[1] * 
nOF(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel);

rOF(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) :=
rOU(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) + 
nS(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel);


drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) := rOF(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) - rIF(z, a_Wheel, b_Wheel);
dnOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) := nOF(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel) - nIF(z, a_Wheel, b_Wheel);

dRdpIO : jacobian([drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[1], 
                   drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[2], 
                   drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[3], 
                   dnOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[1], 
                   drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[2], 
                   drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[3]],
		                                          [ da_O, db_O, dg_O, dx_O, dy_O, dz_O] );
dRdpIOs: dRdpIO;
ratsimp(dRdpIOs);
trigsimp(dRdpIOs);

f90(dRdpIOs);
with_stdout ("DerIO.txt",  f90(dRdpIOs));

/* check ddX/dp */
dXdpIO : jacobian([drOI(z, a_O, b_O, g_O, x_O, y_O, z_O, da_O, db_O, dg_O, dx_O, dy_O, dz_O, a_Wheel, b_Wheel)[1]], 
		                                          [ da_O, db_O, dg_O, dx_O, dy_O, dz_O] );
dXdpIOs: dXdpIO;
ratsimp(dXdpIOs);
trigsimp(dXdpIOs);

f90(dXdpIOs);
with_stdout ("dXdpIO.txt",  f90(dXdpIOs));

define(FuncdRdpIO(da_O, db_O, dg_O, dx_O, dy_O, dz_O), dRdpIOs);

FuncdRdpIOat0: FuncdRdpIO(0, 0, 0, 0, 0, 0);

ratsimp(FuncdRdpIOat0);
trigsimp(FuncdRdpIOat0);

f90(FuncdRdpIOat0);
with_stdout ("FuncdRdpIOat0.txt",  f90(FuncdRdpIOat0));
